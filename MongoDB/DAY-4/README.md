# MongoDB 기초 및 개념

1. **MongoDB는 어떤 유형의 데이터베이스이며, 어떤 형식으로 데이터를 저장합니까? MongoDB의 스키마 특성에 대해 설명하세요.**

   ### **유형**

   - 문서 지향 데이터베이스
   - 문서(Document), 컬렉션(Collection) 방식으로 데이터를 저장

   ### 특성

   - 스키마리스 : 문서가 서로 다른 구조를 가지며, 데이터 모델링이 유연함
   - 다양한 데이터 타입 지원 : BSON은 JSON의 확장이며, 복잡한 데이터 구조를 쉽게 표현
   - 버전 관리 용이 : 스키마가 고정되어 있지 않아 요구사항에 따라 데이터 구조를 쉽게 변경
   - 인덱스 지원 : 다양한 인덱스를 지원하여 쿼리성능을 최적화 가능, 특정 필드에 대해 생성 가능하며 복합 인덱스도 가능

1. **MongoDB에서 문서(Document)와 컬렉션(Collection)의 개념을 설명하고, SQL에서 테이블(Table)과의 차이점을 비교하세요.**

   ### 개념

   - 문서 : 기본 데이터 단위로 키-값 쌍으로 구성된 데이터 구조, 고유한 id 필드를 가지며 다양한 데이터 타입을 포함
   - 컬렉션 : 문서들이 모여 있는 집합으로 관계형 DB의 테이블에 해당되 같은 컬렉션 내의 문서들은 서로 다른 구조를 가짐

   ### 차이점

   - 스키마 유연성:
     - MongoDB: 문서는 스키마리스로, 같은 컬렉션 내의 문서들이 서로 다른 구조를 가짐
     - SQL: 테이블은 고정된 스키마를 가짐, 모든 행은 동일한 열 구조를 가져야 함
   - 데이터 형식:
     - MongoDB: 문서는 BSON 형식으로 저장, 복잡한 데이터 구조(중첩된 문서, 배열 등)를 지원
     - SQL: 데이터는 행과 열로 구성, 각 열은 미리 정의된 데이터 타입을 가짐
   - 확장성:
     - MongoDB: 수평적 확장이 용이, 데이터가 증가함에 따라 쉽게 서버를 추가가 가능
     - SQL: 수직적 확장이 일반적이며, 데이터베이스의 성능을 높이기 위해 더 강력한 하드웨어를 사용하는 경우가 많음
   - 쿼리 언어:
     - MongoDB: MongoDB는 JavaScript 기반의 쿼리 언어를 사용하여 데이터를 조회하고 조작함
     - SQL: SQL(Structured Query Language)을 사용하여 데이터를 조회하고 조작함

1. **MongoDB에서 스키마리스(Schemaless) 데이터베이스의 장점과 단점을 설명하세요.**

   ### 장점

   - 유연성:
     - 스키마리스 데이터베이스는 데이터 구조를 미리 정의할 필요가 없음, 다양한 형태의 데이터를 쉽게 저장. 이는 애플리케이션의 요구 사항이 변화할 때 유연하게 대응할 수 있음
   - 빠른 개발:
     - 데이터 모델을 사전에 설계할 필요가 없음, 개발 초기 단계에서 빠르게 프로토타입을 만들고 테스트 가능 이는 Agile 개발 방식에 적합
   - 다양한 데이터 유형 지원:
     - 스키마리스 데이터베이스는 JSON, BSON 등 다양한 데이터 형식을 지원하여, 복잡한 데이터 구조(예: 중첩된 객체, 배열 등)를 쉽게 저장
   - 스케일 아웃(Scale-out) 용이:
     - 수평적 확장이 용이하여, 데이터가 증가함에 따라 서버를 추가하는 방식으로 쉽게 확장가능. 이는 클라우드 환경에서 유리

   ### 단점

   - 데이터 무결성: 스키마가 없기 때문에 데이터의 일관성과 무결성을 보장하기 어려움, 잘못된 데이터 형식이나 누락된 필드 발생 가능성이 있음
   - 쿼리 복잡성 : 데이터 구조가 유동적, 복잡한 쿼리를 작성할 때 어려움이 있음. 데이터 간의 관계를 명확히 정의하기 어려워 JOIN 연산이 필요할 경우 비효율적임
   - 성능 문제 : 데이터가 비정형으로 저장, 특정 쿼리의 성능이 저하, 인덱스 설정이 복잡해질 수 있으며, 이는 조회 성능에 영향 미침.
   - 관리 및 유지보수 : 스키마가 없기 때문에 데이터 구조의 변경이나 관리가 복잡, 데이터의 구조가 명확하지 않으면, 데이터의 이해와 유지보수가 어려워짐

1. **MongoDB의 주요 특징 중 수평적 확장성에 대해 설명하고, 샤딩(Sharding)이 어떻게 수평적 확장을 지원하는지 서술하세요.**

   ### 수평적 확장성

   - 여러 대의 서버를 추가하여 시스템의 처리 능력을 향상시키는 방식.

   ### 샤딩(Sharding)

   - 데이터 분산 : MongoDB는 데이터를 샤드 키(Shard Key)를 기준으로 여러 샤드에 분산 저장. 샤드 키는 데이터를 어떻게 나눌지를 결정하는 필드로, 이를 통해 데이터가 균형 있게 분산할 수 있음
   - 로드 밸런싱 : 샤딩을 통해 데이터가 여러 서버에 분산, 각 서버에 대한 요청이 분산되어 로드 밸런싱을 이룸, 이는 특정 서버에 부하가 집중되는 것을 방지, 전체 시스템의 성능을 향상시킴.
   - 확장 용이성 : 새로운 샤드를 추가하는 것이 비교적 간단, 데이터가 증가함에 따라 필요에 따라 서버를 추가 가능. 이를 통해 데이터베이스의 용량과 성능을 쉽게 확장할 수 있음.
   - 고가용성 : MongoDB는 샤드마다 복제본을 유지 가능하여, 데이터의 가용성을 높임. 만약 하나의 샤드가 실패하더라도 다른 샤드에서 데이터를 복구할 수 있음
   - 쿼리 처리 : MongoDB는 클라이언트의 쿼리를 분석하여 필요한 샤드에서만 데이터를 조회할 수 있도록 최적화함. 이를 통해 쿼리 성능을 향상시킬 수 있음.

1. **MongoDB에서 BSON(Binary JSON) 형식이 사용되는 이유와 이 형식의 주요 특징에 대해 설명하세요.**

   ### BSON 사용 이유

   - 효율적인 데이터 저장
     - BSON은 JSON보다 더 많은 데이터 유형을 지원, 이진 형식으로 데이터를 저장하기 때문에 저장 공간을 더 효율적으로 사용할 수 있음. 이는 대량의 데이터를 처리할 때 유리.
   - 빠른 데이터 처리
     - BSON은 이진 형식으로 인코딩되어 있어, JSON보다 더 빠르게 읽고 쓸 수 있음. 이는 데이터베이스의 성능을 향상시키는 데 기여함.
   - 유연한 데이터 구조
     - BSON은 동적 스키마를 지원하여, 다양한 데이터 구조를 쉽게 저장함.
   - 다양한 데이터 타입 지원
     - BSON은 문자열, 정수, 부동 소수점, 날짜, 배열, 객체 등 다양한 데이터 타입을 지원. 이는 복잡한 데이터 구조를 표현하는 데 유리.

   ### BSON의 주요 특징

   - 이진 형식
     - BSON은 이진 형식으로 데이터를 저장, JSON보다 더 작은 크기로 데이터를 표현. 이로 인해 네트워크 전송 시 대역폭을 절약함.
   - 데이터 타입
     - BSON은 JSON에서 지원하지 않는 데이터 타입(예: 날짜, 정규 표현식, 이진 데이터 등)을 지원. 이는 다양한 형태의 데이터를 저장할 수 있게 해줌.
   - 크기 제한
     - BSON 문서는 최대 16MB까지 지원. 이는 MongoDB에서 저장할 수 있는 문서의 크기를 제한하지만, 대부분의 애플리케이션에서는 충분한 크기.
   - 인덱싱 지원
     - BSON 형식은 MongoDB의 인덱싱 기능과 잘 통합되어 있어, 효율적인 쿼리 성능을 제공. BSON 문서의 필드에 대해 인덱스를 생성할 수 있음.
   - 구조적 데이터
     - BSON은 중첩된 문서와 배열을 지원하며, 복잡한 데이터 구조를 쉽게 표현할 수 있음. 이는 MongoDB의 유연한 데이터 모델링에 기여함.

---

# MongoDB 트랜잭션 관련

1. **MongoDB에서 멀티 도큐먼트 트랜잭션(Multi-Document Transaction)이 무엇이며, 어떻게 작동하는지 설명하세요.**

### **멀티 도큐먼트 트랜잭션이란?**

- 여러 도큐먼트에 걸쳐 원자성을 보장하는 기능
- 여러 도큐먼트에 대한 읽기 및 쓰기 작업을 하나의 트랜잭션으로 묶어, 모든 작업이 성공적으로 완료되거나, 하나라도 실패할 경우 모든 작업이 롤백되는 방식이며 데이터의 일관성을 유지하는 데 중요한 역할

### 멀티 도큐먼트 트랜잭션의 작동 방식

- 트랜잭션 시작
  - 트랜잭션은 `startTransaction()` 메서드를 호출하여 시작. 이 메서드는 세션을 통해 호출되며, 트랜잭션이 시작된 후에는 여러 도큐먼트에 대한 작업을 수행할 수 있음
- 작업 수행
  - 트랜잭션 내에서 여러 도큐먼트에 대한 읽기 및 쓰기 작업을 수행할 수 있음. 이 작업들은 모두 트랜잭션의 일환으로 처리되며, 중간 상태는 외부에서 볼 수 없음
- 트랜잭션 커밋
  - 모든 작업이 성공적으로 완료되면 `commitTransaction()` 메서드를 호출하여 트랜잭션을 커밋. 이 시점에서 모든 변경 사항이 데이터베이스에 반영됨
- 트랜잭션 롤백
  - 만약 트랜잭션 내에서 오류가 발생하거나 특정 조건이 충족되지 않으면 `abortTransaction()` 메서드를 호출하여 트랜잭션을 롤백할 수 있음. 이 경우, 트랜잭션 내에서 수행된 모든 작업은 취소되고, 데이터베이스는 트랜잭션 시작 전의 상태로 되돌아감

1. **MongoDB 트랜잭션의 ACID 속성(Atomicity, Consistency, Isolation, Durability)에 대해 설명하고, 각 속성이 트랜잭션에서 어떤 역할을 하는지 서술하세요.**

   ### 속성

   ### **1. 원자성 (Atomicity)**

   - 트랜잭션 내의 모든 작업이 성공적으로 완료되거나, 하나라도 실패할 경우 모든 작업이 롤백되어 이전 상태로 되돌아가는 속성
   - 트랜잭션이 부분적으로 수행되는 것을 방지해 데이터의 일관성을 유지합니다.

   ### 2. 일관성 (Consistency)

   - 트랜잭션이 완료되면 데이터베이스는 일관된 상태를 유지해야 한다는 속성
   - 데이터베이스의 무결성을 보장. 예를 들어, 특정 계좌의 잔액이 음수가 되지 않도록 하는 제약 조건이 있을 경우, 트랜잭션이 완료된 후에도 이 제약 조건이 유지되어야 함 트랜잭션이 실패하면 데이터는 이전의 일관된 상태로 되돌아감

   ### 3. 격리성 (Isolation)

   - 동시에 실행되는 트랜잭션들이 서로의 작업에 영향을 미치지 않도록 보장하는 속성 각 트랜잭션은 독립적으로 실행되어야 하며, 다른 트랜잭션의 중간 결과를 볼 수 없습니다.
   - 동시성 문제를 방지 예를 들어, 두 개의 트랜잭션이 동시에 같은 도큐먼트를 수정하려고 할 때, 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션은 대기 이를 통해 데이터의 일관성을 유지 충돌이나 데이터 손상을 방지

   ### 4. 지속성 (Durability)

   - 트랜잭션이 성공적으로 커밋되면 그 결과는 영구적으로 데이터베이스에 저장되어야 한다는 속성 시스템 장애가 발생하더라도 커밋된 데이터는 손실되지 않아야 함
   - 데이터의 안전성을 보장. 예를 들어, 트랜잭션이 성공적으로 완료된 후 시스템이 다운되더라도, 해당 트랜잭션의 결과는 데이터베이스에 남아 있어야 하며 MongoDB는 이를 위해 로그를 사용하여 커밋된 트랜잭션의 데이터를 안전하게 저장

1. **M**ongoDB 트랜잭션 사용 시, 데이터 일관성을 보장하기 위해 사용하는 `commitTransaction()`과 `abortTransaction()` 메서드의 역할을 설명하세요.

   ### **1. `commitTransaction()`**

   - `commitTransaction()` 메서드는 트랜잭션 내에서 수행된 모든 작업을 영구적으로 데이터베이스에 적용하는 역할. 이 메서드가 호출되면, 트랜잭션 동안 변경된 모든 데이터가 커밋되어 데이터베이스의 상태가 업데이트됨

   ### **2. `abortTransaction()`**

   - `abortTransaction()` 메서드는 트랜잭션 내에서 수행된 모든 작업을 취소하고, 데이터베이스를 트랜잭션 시작 전의 상태로 되돌리는 역할을 합니다. 이 메서드가 호출되면, 트랜잭션 동안의 모든 변경 사항은 무효화됨

1. MongoDB에서 트랜잭션을 사용할 수 있는 환경을 설**명하고, 단일 인스턴스에서 트랜잭션이 가능한지 여부를 기술하세요.**

   ### **트랜잭션 사용 환경**

   - Replica Set
     - MongoDB의 트랜잭션 기능은 주로 Replica Set 환경에서 지원
     - Replica Set은 데이터의 고가용성과 내결함성을 제공하는 MongoDB의 클러스터 구성 방식으로, 여러 개의 노드가 서로 복제하여 데이터를 유지
     - 트랜잭션은 이러한 Replica Set 내에서 여러 문서에 걸쳐 원자성을 보장
   - Sharded Cluster
     - MongoDB는 샤딩(sharding)된 클러스터에서도 트랜잭션을 지원, 이 경우, 트랜잭션은 여러 샤드에 걸쳐 수행될 수 있으며, MongoDB는 이를 관리하여 데이터의 일관성을 유지, 그러나 샤딩된 환경에서 트랜잭션을 사용할 때는 성능과 복잡성에 유의
   - MongoDB 버전
     - 트랜잭션 기능은 MongoDB 4.0 이상에서 지원됩니다. 따라서, 이 버전 이상을 사용하는 경우에만 트랜잭션을 활용할 수 있음

   ### 단일 인스턴스에서의 트랜잭션 가능 여부

   - MongoDB의 단일 인스턴스(Standalone) 환경에서는 트랜잭션을 사용할 수 없음
   - 트랜잭션은 원자성을 보장하기 위해 여러 문서에 대한 일관된 상태를 유지해야 하며, 이는 Replica Set 또는 Sharded Cluster와 같은 분산 환경에서만 가능
   - 단일 인스턴스에서는 여러 문서에 대한 원자적 작업을 수행할 수 없기 때문에, 트랜잭션 기능이 지원되지 않음

1. **MongoDB에서 트랜잭션을 구현한 예시 코드를 제시하고, 각 단계별로 동작 방식을 설명하세요.**

```sql
import { MongoClient } from 'mongodb';

const uri = 'mongodb://localhost:27017'; // MongoDB 연결 URI
const client = new MongoClient(uri);

async function runTransaction() {
  const session = client.startSession(); // 트랜잭션을 시작할 세션 생성
  const usersCollection = client.db('bank').collection('users');
  const accountsCollection = client.db('bank').collection('accounts');

  // 트랜잭션 시작
  session.startTransaction();

  try {
    // Step 1: 송금자 계좌에서 100$ 차감
    await accountsCollection.updateOne(
      { accountId: '12345' }, // 송금자 계좌 ID
      { $inc: { balance: -100 } }, // 잔액 100$ 차감
      { session } // 트랜잭션 세션 사용
    );

    // Step 2: 수신자 계좌에 100$ 추가
    await accountsCollection.updateOne(
      { accountId: '67890' }, // 수신자 계좌 ID
      { $inc: { balance: 100 } }, // 잔액 100$ 추가
      { session } // 트랜잭션 세션 사용
    );

    // 트랜잭션 커밋 (성공 시)
    await session.commitTransaction();
    console.log('Transaction successfully committed.');

  } catch (error) {
    // 오류 발생 시 트랜잭션 롤백
    await session.abortTransaction();
    console.error('Transaction aborted due to an error: ', error);
  } finally {
    // 세션 종료
    session.endSession();
    await client.close();
  }
}

runTransaction().catch(console.error);
```

---

# 샤딩(Sharding) 관련

1. **MongoDB에서 샤딩(Sharding)이란 무엇이며, 이를 통해 데이터베이스 성능을 어떻게 최적화할 수 있는지 설명하세요.**

   ### 샤딩이란?

   - 데이터를 여러 서버(샤드)에 분산 저장하는 방식이며 이를 통해 데이터를 수평적으로 확장(**horizontal scaling**)할 수 있음
   - 샤딩은 특히 **빅데이터**와 **대용량 트래픽**을 처리해야 하는 시스템에서 필수적인 기술

   ### **성능 최적화 방법**

   - **수평적 확장**
     - **데이터가 여러 샤드에 분산되므로, 데이터베이스의 용량과 처리 능력을 쉽게 확장할 수 있음.**
   - **부하 분산**
     - **쿼리와 데이터 저장 요청이 여러 샤드에 분산되므로, 특정 서버에 부하가 집중되지 않고 전체적으로 균형 잡힌 성능을 유지할 수 있음**
   - **병렬 처리**
     - **여러 샤드에서 동시에 쿼리를 처리할 수 있어, 대량의 데이터에 대한 읽기 및 쓰기 작업이 더 빠르게 수행됨**
   - **데이터 지역성**
     - **특정 샤드에 관련 데이터를 저장함으로써, 데이터 접근 속도를 높이고 네트워크 지연을 줄일 수 있음**

1. **MongoDB에서 샤드 키(Shard Key)의 역할과, 샤드 키를 선택할 때 고려해야 할 요소들을 설명하세요.**

   ### 샤드키의 역할

   - 샤드 키는 데이터를 여러 샤드에 균등하게 분산시키는 역할
   - 샤드 키를 기반으로 쿼리가 실행되므로, 적절한 샤드 키는 쿼리 성능을 향상
   - 샤드 키는 데이터의 위치를 결정하므로, 데이터의 추가, 삭제, 업데이트 시 관리의 용이성을 제공

   ### **샤드 키 선택 시 고려해야 할 요소**

   - 데이터 분포
     - 샤드 키는 데이터가 균등하게 분포되도록 선택해야 함
     - 특정 값에 데이터가 집중되면, 해당 샤드에 부하가 몰려 성능 저하가 발생
   - 쿼리 패턴
     - 자주 사용되는 쿼리의 필드를 샤드 키로 선택하면 쿼리 성능을 최적화할 수 있음
   - 변경 가능성
     - 샤드 키는 변경하기 어렵기 때문에, 자주 변경되지 않는 필드를 선택하는 것이 좋으며 변경이 잦은 필드는 데이터 이동을 초래하여 성능에 악영향을 미칠 수 있음
   - 데이터 크기
     - 샤드 키의 크기도 고려해야 함, 너무 큰 샤드 키는 인덱스 크기를 증가시켜 성능을 저하시킴
   - 샤드 수
     - 샤드의 수와 샤드 키의 선택이 잘 맞아야 함. 샤드 수가 많을수록 샤드 키의 다양성이 중요해짐

1. **MongoDB에서 샤딩 구조의 주요 구성 요소(샤드, 쿼리 라우터, 컨피그 서버)를 설명하고, 각 구성 요소가 어떻게 상호작용하는지 서술하세요.**

   ### 구성요소

   1. 샤드(Shard)
      - 실제 데이터를 저장하는 데이터베이스로 각 샤드는 전체 데이터의 일부를 저장하며, 샤드는 자체적으로 레플리카 세트로 구성될 수 있음(샤드 자체가 고가용성을 위해 복제될 수 있음).
   2. 쿼리 라우터(Query Router)
      - MongoS라는 프로세스가 쿼리 라우터 역할로 클라이언트가 MongoDB에 요청을 보낼 때, 쿼리 라우터는 어떤 샤드가 해당 데이터를 가지고 있는지 결정하고 쿼리를 적절한 샤드에 전달
   3. 컨피그 서버(Config Server)
      - 클러스터에서 데이터가 각 샤드에 어떻게 분배되는지를 추적하는 메타데이터를 저장하며 컨피그 서버는 각 샤드가 어떤 데이터 범위를 가지고 있는지 관리

   ### 상호작용 요약

   - 클라이언트가 쿼리를 보내면, 쿼리 라우터가 이를 수신함
   - 쿼리 라우터는 컨피그 서버에 접근하여 필요한 메타데이터를 조회함
   - 조회된 정보를 바탕으로 쿼리 라우터는 적절한 샤드로 쿼리를 전달함
   - 샤드는 요청을 처리하고 결과를 쿼리 라우터에 반환함
   - 쿼리 라우터는 최종 결과를 클라이언트에 전달함

1. **MongoDB에서 Range-based Sharding과 Hash-based Sharding의 차이점을 설명하고, 각각의 장단점을 비교하세요.**

   | **특성**             | **Range-based Sharding**  | **Hash-based Sharding**          |
   | -------------------- | ------------------------- | -------------------------------- |
   | **데이터 분포 방식** | **특정 범위에 따라 분산** | **해시 값을 기반으로 균등 분산** |
   | **쿼리 성능**        | **범위 쿼리에 유리**      | **범위 쿼리에 불리**             |
   | **데이터 불균형**    | **발생할 수 있음**        | **최소화됨**                     |
   | **확장성**           | **제한적일 수 있음**      | **용이함**                       |
   | **정렬된 결과**      | **쉽게 얻을 수 있음**     | **추가 작업 필요**               |

   ### **Range-based Sharding**

   **장점:**

   - **쿼리 성능**
     - **범위 기반 쿼리(예: 특정 날짜 범위의 데이터 조회)에 대해 성능이 우수. 데이터가 연속적으로 저장되기 때문에, 특정 범위의 데이터를 쉽게 찾을 수 있음**
   - **데이터 정렬**
     - **데이터가 샤드 내에서 정렬된 상태로 저장되므로, 정렬된 결과를 쉽게 얻을 수 있음**

   **단점:**

   - **데이터 불균형**
     - **특정 범위에 데이터가 집중될 경우, 일부 샤드에 데이터가 과도하게 쏠릴 수 있음 이로 인해 샤드 간의 데이터 불균형이 발생할 수 있음**
   - **스케일링 문제**
     - **데이터가 특정 범위에 집중되면, 새로운 샤드를 추가할 때 기존 샤드의 데이터가 불균형하게 분포될 수 있**

   ### **Hash-based Sharding**

   **장점:**

   - **균형 잡힌 데이터 분포**
     - **해시 함수를 사용하여 데이터를 분산하므로, 데이터가 샤드 간에 균형 있게 분포됨 이는 데이터 불균형 문제를 최소화함**
   - **확장성**
     - **새로운 샤드를 추가할 때 기존 데이터의 재분배가 상대적으로 용이하여, 시스템의 확장성이 높음**

   **단점:**

   - **쿼리 성능**
     - **특정 범위의 데이터를 조회할 때 성능이 떨어질 수 있습니다. 해시 기반 분산으로 인해 데이터가 여러 샤드에 분산되어 있어, 범위 쿼리를 수행할 때 모든 샤드를 조회해야 할 수 있습니다.**
   - **정렬 문제**
     - **데이터가 해시 값에 따라 분산되므로, 정렬된 결과를 얻기 위해 추가적인 작업이 필요할 수 있습니다.**

1. **MongoDB에서 샤딩의 장점과 단점을 설명하고, 샤딩이 적합한 상황과 그렇지 않은 상황에 대해 논하세요.**

   ### 장점

   1. 수평적 확장: 대량의 데이터를 여러 서버에 분산하여 저장하므로, 데이터의 크기가 커지거나 트래픽이 증가할 때 시스템 성능을 유지할 수 있음
   2. 성능 최적화: 데이터를 분산하여 저장하기 때문에, 쿼리가 특정 샤드에만 접근하게 되어 전체 시스템의 처리 성능이 향상됨
   3. 장애 대응: 일부 샤드에 장애가 발생해도 다른 샤드들이 정상적으로 작동하며, 전체 시스템의 가용성을 유지할 수 있음

   ### 단점

   1. 복잡한 관리: 샤딩을 설정하고 관리하는 데는 상당한 복잡성이 따름 특히, 잘못된 샤드 키 선택은 성능 문제를 일으킬 수 있음
   2. 운영 비용 증가: 샤딩을 사용할 경우 더 많은 서버가 필요하므로, 하드웨어와 유지 관리 비용이 증가할 수 있음

   ### 적합한 상황

   - 대규모 데이터베이스: 데이터 크기가 단일 서버의 용량을 초과하는 경우
   - 높은 트래픽 처리: 동시에 수많은 요청을 처리해야 하는 웹 애플리케이션
   - 성능 최적화: 대규모 데이터에 대한 빠른 조회와 쓰기가 필요한 경우

   ### 적합하지 않은 상황

   - 소규모 데이터베이스 : 데이터의 양이 적고 단일 서버로 충분히 처리할 수 있는 경우
   - 간단한 쿼리 요구 : 복잡한 쿼리나 범위 쿼리가 많지 않은 경우
   - 운영 비용을 최소화해야 하는 경우 : 예산이 제한적이거나 운영비용을 최소화 해야하는 경우 (여러서버를 운영해야 하므로 하드웨어 및 관리 비용이 증가할 수 있음)

---

# 레플리카 세트(Replica Set) 관련

1. **MongoDB에서 레플리카 세트(Replica Set)란 무엇이며, 이 기능을 사용하는 주된 목적에 대해 설명하세요.**

   ### 레플리카 세트(Replica Set)란?

   - 데이터의 가용성과 내구성을 높이고, 읽기 성능을 향상시키며, 장애 발생 시 신속한 복구를 가능하게 하는 중요한 기능

   ### 레플리카 세트의 주요 목적

   - 고가용성(High Availability)
     - Primary에 장애가 발생할 경우, Secondary 중 하나가 자동으로 새로운 Primary로 승격되어 서비스 중단 없이 데이터베이스를 계속 운영할 수 있음 이를 통해 시스템의 가용성을 높임
   - 데이터 내구성(Data Durability)
     - 데이터가 여러 노드에 복제되므로, 하나의 노드에서 데이터가 손실되더라도 다른 노드에서 데이터를 복구할 수 있음 이는 데이터 손실의 위험을 줄임.
   - 읽기 성능 향상
     - Secondary에서 읽기 작업을 수행할 수 있어, 읽기 부하를 분산시킬 수 있음 이를 통해 전체 시스템의 성능을 향상시킬 수 있음
   - 장애 복구(Failover)
     - Primary에 문제가 발생하면, 레플리카 세트는 자동으로 Secondary 중 하나를 Primary로 승격시키는 장애 복구 기능을 제공 이 과정은 사용자 개입 없이 자동으로 이루어짐
   - 데이터 백업 및 복원:
     - Secondary를 사용하여 데이터 백업을 수행할 수 있으며, 이를 통해 데이터 복원 작업을 보다 용이하게 할 수 있음

1. **MongoDB 레플리카 세트의 구성 요소인 Primary, Secondary, Arbiter의 역할과 동작 방식을 설명하세요.**

   ### Primary (주 노드)

   - 역할: 데이터 쓰기 작업을 처리.
   - 동작: 클라이언트의 요청을 받아 데이터를 업데이트하고, Secondary에 복제.

   ### Secondary (보조 노드)

   - 역할: Primary의 데이터를 복제하고 읽기 작업을 처리.
   - 동작: Primary의 변경 사항을 지속적으로 복제하며, Primary 장애 시 승격 가능.

   ### Arbiter (중재자)

   - 역할: Primary 선출을 위한 투표 참여.
   - 동작: 데이터 저장소 없이 투표만 수행하여 Primary 선출을 지원.

1. **MongoDB에서 레플리카 세트를 사용하는 경우, Primary 서버에 장애가 발생했을 때 어떤 과정으로 장애를 복구하는지 서술하세요.**

   1. Secondary 서버가 자동으로 Primary로 승격

1. **MongoDB에서 Secondary 서버를 활용한 읽기 작업 분산이 무엇인지 설명하고, 이 방법이 읽기 성능에 어떤 영향을 미치는지 논하세요.**

   1. 읽기 작업 분산은 읽기 요청을 Primary 서버가 아닌 Secondary 서버로 분산시켜 처리하는 방법
   2. 여러 서버에서 읽기 요청을 처리함으로써 부하를 분산시키고, Primary 서버의 성능 저하를 방지

1. **레플리카 세트와 샤딩의 차이점을 설명하고, 두 기능을 함께 사용할 경우의 장점에 대해 서술하세요.**

   ### 레플리카 세트와 샤딩의 차이점

   레플리카 세트

   - 데이터의 복제본을 여러 서버에 유지하여 고가용성과 읽기 성능을 향상시키는 기능

   샤딩

   - 데이터를 여러 서버에 분산 저장하여 데이터베이스의 용량과 성능을 확장하는 방법

   ### 장점

   - 레플리카 세트로 읽기 성능과 가용성을 높이면서, 샤딩으로 데이터 용량을 확장해 대규모 데이터베이스 환경에서도 효율적인 성능과 안정성을 유지할 수 있음

---
